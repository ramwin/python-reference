**Xiang Wang @ 2019-04-23 11:24:00**


## 创建型模式
### 工厂模式

* 示例: 根据输入的颜色名, 产生对应的颜色的class


    class Color(object):
        pass


    class Red(Color):
        color = 'red'


    class Green(Color):
        color = 'green'


    class Factory(object):

        def get_color(self, name):
            if name == 'red':
                return Red()
            if name == 'green':
                return Green()
            raise NotImplemented

* 我用过工厂模式的地方:  
> 给小荐开发时, 公司信息. 有个通用的CompanyInfo, 然后不同公司, 有ContactInfo, AddressInfo, ProductInfo. 他们的操作都是获取数据, 处理数据, 保存数据, 都有缓存机制. 然后一个请求过来, 不同的View就是调用了不同的Info, 然而其他处理机制都一样

### 抽象工厂模式

1. 传入参数,获取某个工厂
2. 传入参数,通过工厂获取类


    shapeFactory = FactoryProducer.getFactory("SHAPE")
    shape = shapeFactory.getShare("CIRCLE")
    shape.draw()
    colorFactory = FactoryProducer.getFactory("COLOR")
    color = colorFactory.getColor("RED")
    color.fill()


### [单例模式](./设计模式/单例模式.py)
一个class只能实例化一次

* 我用过的地方:
> 开发交易日获取的时候, 因为要请求交易日列表并解析(慢),所以希望只初始化一次

## 结构性模式
### [桥接模式](./设计模式/桥接模式.py)
形状和颜色组合类型为M X N, 如果只考虑形状, 把颜色类型当作参数传给Shape, 就能避免创建M X N个类.  
为什么不把Red和Green当作参数传给shape? 因为这样就要求shape里面包含所有颜色的paint方法. 可能红色的要拿到血, 绿色的要除个草, 这样shape就太复杂了.
```
class ColorPaint:
    def paint(self):
        pass

class GreenPaint:
    pass

class RedPaint:
    pass

class Shape:
    def __init__(self, shape_name, color_paint: ColorPaint):
        self.color_paint = color_paint

    def draw(self):
        self.draw_outline()
        self.color_paint.paint()

Shape("长方形", RedPaint).draw()
Shape("圆形", GreenPaint).draw()
```
